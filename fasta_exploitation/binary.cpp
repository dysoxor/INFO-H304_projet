#include "binary.h"

template< typename T >
std::string int_to_hex( T i )
{
  std::stringstream stream;
  stream << "0x"
         << std::setfill ('0') << std::setw(sizeof(T)*2)
         << std::hex << i;
  return stream.str();
}
//ze test
void PIN::read(){
  ifstream filePIN;
  filePIN.open("uniprot_sprot.fasta.pin", ios::binary | ios::in);

  filePIN.seekg(0, ios::end);
  int size=filePIN.tellg();
  filePIN.seekg(0, ios::beg);

  cout << "File size is : " << size << endl;

  filePIN.read( (char *)&version, sizeof(uint32_t));
  version = __bswap_32(version);
  cout << "The version is : " << version << endl;

  filePIN.read( (char*)&database_type, sizeof(uint32_t));
  database_type = __bswap_32(database_type);
  cout << "The database type is : " << database_type << endl;

  filePIN.read( (char*)&title_length, sizeof(uint32_t));
  title_length = __bswap_32(title_length);
  cout << "The title length is : " << title_length << endl;

  title = new char[title_length];
  filePIN.read((char*)title, sizeof(char)*title_length);
  cout << "The title is : ";
  for (int i=0; i < title_length; i++){
    cout << title[i];
  }
  cout << endl;

  filePIN.read( (char*)&timestamp_length, sizeof(uint32_t));
  timestamp_length = __bswap_32(timestamp_length);
  cout << "The timestamp length is : " << timestamp_length << endl;

  timestamp = new char[timestamp_length];
  filePIN.read((char*)timestamp, sizeof(char)*timestamp_length);
  cout << "The timestamp is : ";
  for (int i=0; i < timestamp_length; i++){
    cout << timestamp[i];
  }
  cout << endl;

  filePIN.read( (char*)&num_of_seq, sizeof(uint32_t));
  num_of_seq = __bswap_32(num_of_seq);
  cout << "The number of sequences is : " << num_of_seq << endl;

  filePIN.read( (char*)&residue_count, sizeof(uint64_t));
  cout << "The residue count is : " << residue_count << endl;

  filePIN.read( (char*)&max_seq, sizeof(uint32_t));
  max_seq = __bswap_32(max_seq);
  cout << "The maximum sequence is : " << max_seq << endl;

  hr_offset_table = new uint32_t[num_of_seq+1];
  int sizeTable = sizeof(uint32_t)*(num_of_seq+1);
  filePIN.read((char*)hr_offset_table, sizeTable);
  cout << "The header offset table is : " << endl;
  for (int i=0; i < num_of_seq+1; i++){
    hr_offset_table[i] = __bswap_32(hr_offset_table[i]);
    //if( hr_offset_table[i] != 0)
    //cout << "[" << i << "]" << hr_offset_table[i] << endl;
  }

  seq_offset_table = new uint32_t[num_of_seq+1];
  filePIN.read((char*)seq_offset_table, sizeTable);
  cout << "The sequences offset table is : " << endl;
  for (int i=0; i < num_of_seq+1; i++){
    seq_offset_table[i] = __bswap_32(seq_offset_table[i]);
    //if( hr_offset_table[i] != 0)
    //cout << "[" << i << "]" << hr_offset_table[i] << endl;
  }

  filePIN.close();

}

int PIN::getNumSeq()const{
  return num_of_seq;
}

int PIN::getHrOffset(int i)const{
  return hr_offset_table[i];
}

int PIN::getSqOffset(int i)const{
  return seq_offset_table[i];
}

int PSQ::read(PIN* filePIN, string query){
  vector<int> table_query = queryToInt(query);

  ifstream filePSQ;
  filePSQ.open("uniprot_sprot.fasta.psq", ios::binary | ios::in);

  filePSQ.seekg(0, ios::end);
  int size=filePSQ.tellg();
  filePSQ.seekg(0, ios::beg);

  cout << "File size is : " << size << endl;
  int num = filePIN->getSqOffset(1);

  bool finded = false;
  int sizeOfSq;
  int index = -1;
  for (int i = 0; i < filePIN->getNumSeq(); i++){
    if (finded){
      break;
    }
    sizeOfSq = filePIN->getSqOffset(i+1) - filePIN->getSqOffset(i) -1; //car bit 0 pour separer les sq
    if (i == 0){
      sizeOfSq --;
    }
    if (sizeOfSq == table_query.size() ){
      if(i == 0){
        filePSQ.seekg(filePIN->getSqOffset(i)+1);
      } else {
        filePSQ.seekg(filePIN->getSqOffset(i));
      }
      for (int j = 0; j < sizeOfSq+1; j++){
        filePSQ.read((char*)&sequence, sizeof(uint8_t));
        if (sequence != 0){
          if (table_query[j] != sequence){
              break; //on a pas de correspondance parfaite
          }
        }
        else {
            finded = true;
            index = i;
            break;
        }
      }
    }
  }
  if (finded){
    cout << "Trouvé à l'offset n° " << index << endl;
  } else {
    cout << "Pas trouvé, rip" << endl;
  }
  filePSQ.close();
  return index;
}

vector<int> PSQ::queryToInt(string query){
  vector<int> res;
  //const char intToChar[28] = {'-','A','B','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','X','Y','Z','U','*','O','J'};
  map<char,int> intToChar {
    {'-',0},{'A',1},{'B',2},{'C',3},{'D',4},
    {'E',5},{'F',6},{'G',7},{'H',8},{'I',9},
    {'K',10},{'L',11},{'M',12},{'N',13},{'P',14},
    {'Q',15},{'R',16},{'S',17},{'T',18},{'V',19},
    {'W',20},{'X',21},{'Y',22},{'Z',23},{'U',24},
    {'*',25},{'O',26},{'J',27}
  };

  for (int i = 0; i< query.size(); i++){
    int indice = intToChar[query.at(i)];
    res.push_back(indice);
  }

  return res;
}



void PHR::read(PIN* filePIN, int index){
  ifstream filePHR;
  filePHR.open("uniprot_sprot.fasta.phr", ios::binary | ios::in);

  filePHR.seekg(0, ios::end);
  int sizeOfFile=filePHR.tellg();
  filePHR.seekg(0, ios::beg);

  cout << "File size is : " << sizeOfFile << endl;
  int num = filePIN->getHrOffset(index);
  int size = filePIN->getHrOffset(index+1)-num;
  bool visible_string = false;
  int counter=0;
  int byteForSize=0;
  filePHR.seekg(num);
  for(int i=0; i<size ; i++){
    filePHR.read( (char*)&binary, 1);
    hexadecimal = int_to_hex(binary).substr(8, 2);
    if(visible_string){
      if(counter == 0){
        string_length_bits = byteToBits(binary);
        for(int i=0; i<string_length_bits.size(); i++){
          cout << string_length_bits[i];
        }
        cout << endl;
        significantBitOn = false;
        if(string_length_bits[0] == '1'){
          significantBitOn = true;
        }
        cout << "significant Bit is : " << significantBitOn << endl;
        if(!significantBitOn){
          string_length = binary;
          cout << "The string length is : " << string_length << endl;
        }
        else{
          byteForSize = toInt(string_length_bits.substr(1,7));
          cout << "The number of bytes for the size is : " << byteForSize << endl;
          filePHR.read((char *)&string_length, byteForSize);
          string_length = __bswap_32(string_length);
        }
      }
      else if(string_length!=-1){
        title+=hex_to_string(hexadecimal);
        string_length--;
      }

      //cout << "header[" << i << "]" << binary  << "  " << hexadecimal << endl;
      counter++;
    }
    if(hexadecimal == "1a"){
      visible_string = true;
    }
  }
  cout << "The title is : " << title << endl;

  /*int num2 = filePIN->getHrOffset(2);

  for(int i=0; i<num2 -num ; i++){
    filePHR.read( (char*)&binary, 1);
    hexadecimal = int_to_hex(binary).substr(8, 2);
    //cout << "header[" << i << "]" << binary  << "  " << hexadecimal << endl;

  }*/


}

string byteToBits(unsigned int u)
{
  int t;
  string bits;

  for(t=128; t>0; t = t/2) {
    if(u & t) bits+='1';
    else bits+='0';
  }

  return bits;
}

unsigned long toInt(std::string const &s) {
    static const std::size_t MaxSize = CHAR_BIT*sizeof(unsigned long);
    if (s.size() > MaxSize) return 0; // handle error or just truncate?

    std::bitset<MaxSize> bits;
    std::istringstream is(s);
    is >> bits;
    return bits.to_ulong();
}

std::string hex_to_string(const std::string& in) {
    std::string output;

    if ((in.length() % 2) != 0) {
        throw std::runtime_error("String is not valid length ...");
    }

    size_t cnt = in.length() / 2;

    for (size_t i = 0; cnt > i; ++i) {
        uint32_t s = 0;
        std::stringstream ss;
        ss << std::hex << in.substr(i * 2, 2);
        ss >> s;

        output.push_back(static_cast<unsigned char>(s));
    }

    return output;
}

string hexToString(string hexLine){
  const string hexToInt = "0123456789ABCDEF";
  //const char intToChar[28] = {'-','A','B','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','X','Y','Z','U','*','O','J'};
  int hex1;
  int hex0;
  int integer;
  char value;
  string res = "";
  for (int i = 0; i < hexLine.size(); i+=2){
    hex1 = getIndexOf(hexToInt, hexLine[i]);
    hex0 = getIndexOf(hexToInt, hexLine[i+1]);
    integer = hex1*16+hex0;
    value = integer;
    res+=value;
  }
  return res;
}

int getIndexOf(string line, char toFind){
  for (int i = 0; i<line.size(); i++){
    if (line[i] == toFind){
      return i;
    }
  }
}
